<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>Better Monads</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="racket.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" pltdoc="x">Better Monads</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#(part._.Usage)" class="tocviewlink" pltdoc="x">Usage</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#(part._.Other_.Forms_and_.Functions)" class="tocviewlink" pltdoc="x">Other Forms and Functions</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#(part._.Conclusions)" class="tocviewlink" pltdoc="x">Conclusions</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#(part._.Usage)" class="tocsubseclink" pltdoc="x">Usage</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#(part._mlet_)" class="tocsubseclink" pltdoc="x">mlet*</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#(part._.Working_with_a_.Monad)" class="tocsubseclink" pltdoc="x">Working with a Monad</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#(part._.Defining_.Additional_.Monads)" class="tocsubseclink" pltdoc="x">Defining Additional Monads</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#(part._.Lagniappe__.Bonus_.Features_)" class="tocsubseclink" pltdoc="x">Lagniappe (Bonus Features)</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#(part._.Other_.Forms_and_.Functions)" class="tocsubseclink" pltdoc="x">Other Forms and Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#(part._monadic-do)" class="tocsubseclink" pltdoc="x">monadic-<wbr></wbr>do</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#(part._.Bundled_.Monads)" class="tocsubseclink" pltdoc="x">Bundled Monads</a></td></tr><tr><td><span class="tocsublinknumber">2.2.1<tt>&nbsp;</tt></span><a href="#(part._.The_.List_.Monad)" class="tocsubseclink" pltdoc="x">The List Monad</a></td></tr><tr><td><span class="tocsublinknumber">2.2.2<tt>&nbsp;</tt></span><a href="#(part._.The_.State_.Monad)" class="tocsubseclink" pltdoc="x">The State Monad</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#(part._.Other_.Utility_.Functions_.Forms)" class="tocsubseclink" pltdoc="x">Other Utility Functions/<span class="mywbr"> </span>Forms</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#(part._.Conclusions)" class="tocsubseclink" pltdoc="x">Conclusions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">Version: 5.1.3</span></div><h2><a name="(part._.Better_.Monads)"></a>Better Monads</h2><p>This library is an attempt to facilitate pure functional
programming by providing a set of functions and special forms
for working with monads.  It also provides the definition of
several common monads extended in such a way as to make their
use in dynamic languages more convenient.  The user can define
their own monads for later use as well.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Usage)"></a>Usage</h3><p>What follows is a brief tutorial on the usage of this library.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._mlet_)"></a>mlet*</h4><p>The most important special form in the library is the <span class="RktSym">mlet*</span> syntax,
which is the "Schemeish" monadic binding form, rougly equivalent to Haskell&rsquo;s
"do" notation.</p><p>Monads allow you to extend the meaning of variable binding within an <span class="RktSym">mlet*</span>
expression, and hence <span class="RktSym">mlet*</span> is very similar to <span class="RktSym">let*</span>, in that it
takes a series of binding pairs and then evaluates a body of expressions,
as in a <span class="RktSym">begin</span> form.</p><p>In fact, at the top level, <span class="RktSym">mlet*</span> behaves identically to <span class="RktSym">let*</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">require</span><span class="hspace">&nbsp;</span><span class="RktSym">functional/better-monads</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">11</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>By default, <span class="RktSym">mlet*</span> performs its bindings in whatever monad
is stored in the lexical variable <span class="RktSym">current-monad</span>, which
Better Monads exports as the identity monad (also available in the
variable <span class="RktSym">the-identity-monad</span>).</p><p>One difference, which applies to all monads, is that Racket&rsquo;s built-in
"match" patterns can be substituted for the symbols in the binding form.
For example:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">100</span><span class="hspace">&nbsp;</span><span class="RktVal">101</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Will return <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">100</span><span class="stt"> </span><span class="RktVal">101</span><span class="RktVal">)</span>.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Working_with_a_.Monad)"></a>Working with a Monad</h4><p>Besides extending <span class="RktSym">let*</span> with pattern matching, the library
doesn&rsquo;t do much until you start using monads other than
<span class="RktSym">the-identity-monad</span>.  Alternative monads are introduced
using the <span class="RktSym">in:</span> option in <span class="RktSym">mlet*</span>.  For instance:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktSym">in:</span><span class="hspace">&nbsp;</span><span class="RktSym">the-list-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">c</span><span class="hspace">&nbsp;</span><span class="RktVal">d</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Will result in:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">list</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">b</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">c</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">d</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktSym">...</span><span class="RktPn">)</span></td></tr></table></blockquote><p>And so on, to include all the combinations of the items bound to
<span class="RktSym">x</span> and <span class="RktSym">y</span>, which is the behavior of
<span class="RktSym">the-list-monad</span>.</p><p>Note the use of the function <span class="RktSym">return</span> in the body of the
<span class="RktSym">mlet*</span> expression.  In the context of an <span class="RktSym">mlet*</span>
expression, the symbosl <span class="RktSym">bind</span>, and <span class="RktSym">return</span> are
bound to the appropriate functions in the specified monad.  If
the monad also defines <span class="RktSym">plus</span> and/or <span class="RktSym">zero</span>, these
will also be appropriately bound.  Otherwise they will be bound to
<span class="RktVal">#f</span>.  In the lexical scope of an <span class="RktSym">mlet*</span> expression,
the <span class="RktSym">current-monad</span> will be bound to the monad specified
after <span class="RktSym">in:</span>.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Defining_.Additional_.Monads)"></a>Defining Additional Monads</h4><p>The use may define her own monads by creating an instance of the
<span class="RktSym">monad</span> structure.  For instance, we might define the "maybe"
monad like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">struct</span><span class="hspace">&nbsp;</span><span class="RktSym">None</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">maybe-return</span><span class="hspace">&nbsp;</span><span class="RktSym">item</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktSym">item</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">maybe-bind</span><span class="hspace">&nbsp;</span><span class="RktSym">monadic-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">monadic-function</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">monadic-value</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">monadic-function</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">None</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">monadic-value</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">the-maybe-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">monad</span><span class="hspace">&nbsp;</span><span class="RktSym">maybe-bind</span><span class="hspace">&nbsp;</span><span class="RktSym">maybe-return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Having done such, we may write:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktSym">in:</span><span class="hspace">&nbsp;</span><span class="RktSym">the-maybe-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktVal">11</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Which evaluates to <span class="RktPn">(</span><span class="RktSym">Just</span><span class="stt"> </span><span class="RktVal">21</span><span class="RktPn">)</span>.  We might also write:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktSym">in:</span><span class="hspace">&nbsp;</span><span class="RktSym">the-maybe-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">None</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Just</span><span class="hspace">&nbsp;</span><span class="RktVal">13</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Which will evaluate to <span class="RktPn">(</span><span class="RktSym">None</span><span class="RktPn">)</span>.</p><p>In this example, we bound the monad to a symbol, but monads may
be specified anonymously.</p><h4>1.4<tt>&nbsp;</tt><a name="(part._.Lagniappe__.Bonus_.Features_)"></a>Lagniappe (Bonus Features)</h4><p>It is often useful to bind values non-monadically during a monadic
expression.  These can be introduced using the <span class="RktSym">is:</span> syntax.
For instance:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktSym">in:</span><span class="hspace">&nbsp;</span><span class="RktSym">the-list-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktSym">is:</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktVal">b</span><span class="hspace">&nbsp;</span><span class="RktVal">c</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">q</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Will produce <span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">11</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">11</span><span class="stt"> </span><span class="RktSym">b</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">...</span><span class="RktPn">)</span>.  And so on.
The symbol <span class="RktSym">q</span> is bound as in a <span class="RktSym">let</span> expression for all
expressions subsequent.  The binding symbol can also be a <span class="RktSym">match</span>
pattern.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Other_.Forms_and_.Functions)"></a>Other Forms and Functions</h3><p>At the moment, the library provides a few extra functions and features.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._monadic-do)"></a>monadic-do</h4><p>The form <span class="RktSym">monadic-do</span> provides an alternative, more Haskell-ish,
monadic binding form.  Each expression (except the last) in the body of a <span class="RktSym">monadic-do</span>
must be either a binding expression:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">pattern</span><span class="hspace">&nbsp;</span><span class="RktSym">&lt;-</span><span class="hspace">&nbsp;</span><span class="RktSym">monadic-value</span><span class="RktPn">)</span></p></blockquote><p>A "letting" expression:</p><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">pattern</span><span class="hspace">&nbsp;</span><span class="RktSym">is:</span><span class="hspace">&nbsp;</span><span class="RktSym">expression</span><span class="RktPn">)</span></p></blockquote><p>Or an expression resulting in a monadic value.  The last expression in a
monadic-do form can&rsquo;t bind or let any variables, but must evaluate to a monadic
value.  This version of the form might be more useful for monads like the state monad
which have many monadic values for which the resulting binding isn&rsquo;t important.</p><p>Eg:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state-push</span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state-doublet</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">no-one-cares</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktSym">state</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">state-pop</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state-doublet</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">state</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">state</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">monadic-do</span><span class="hspace">&nbsp;</span><span class="RktSym">in:</span><span class="hspace">&nbsp;</span><span class="RktSym">the-state-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state-push</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state-push</span><span class="hspace">&nbsp;</span><span class="RktVal">13</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">&lt;-</span><span class="hspace">&nbsp;</span><span class="RktSym">state-pop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">state-push</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">100</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>That is, we don&rsquo;t care about the value returned by <span class="RktSym">state-push</span>
for binding in subsequent expressions.  This form threads our values
through the monad, but lets us avoid the noise of providing dummy variable names.
Bindings to actual symbols is indicated specifically by <span class="RktSym">&lt;-</span> for
monadic binding and <span class="RktSym">is:</span> for regular binding.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Bundled_.Monads)"></a>Bundled Monads</h4><p>The library comes with several monads pre-defined.  We&rsquo;ve seen most of them
already, but its worth remarking on a few peculiarities.</p><h5>2.2.1<tt>&nbsp;</tt><a name="(part._.The_.List_.Monad)"></a>The List Monad</h5><p>The list monad behaves just like the list monad in Haskell or any other
language, in that bind is essentially "map-cat".  However, unlike in
Haskell, the list monad in this library will "return" non-list values
if they appear where a list should be.  You can say, eg:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">mlet*</span><span class="hspace">&nbsp;</span><span class="RktSym">in:</span><span class="hspace">&nbsp;</span><span class="RktSym">the-list-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara">When "bind" encounters "4" either in a place where a monadic
value or monadic function should be, it replaces it with
the "right" value (either <span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span> or <span class="RktPn">(</span><span class="RktSym">lambda</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">list</span><span class="stt"> </span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span>, respectively).
If you want to return a list, you must <span class="RktSym">return</span> it explicitely.
</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Being able to squeeze values into our monad like this is a nice benefit of working
with monads in a language with run-time type-checking.</p></blockquote></blockquote></blockquote></div></p><h5>2.2.2<tt>&nbsp;</tt><a name="(part._.The_.State_.Monad)"></a>The State Monad</h5><p>The state monad is useful for constructing functions of state
out of smaller state functions.  Monadic values in this monad
are functions which take a state and return a <span class="RktSym">state-doublet</span> struct.
The first part of this doublet is the "proper return value" of the state
function, which is the value bound in binding expressions.  The second
value is the modified state.</p><p>Like <span class="RktSym">the-list-monad</span>, <span class="RktSym">the-state-monad</span> makes an attempt
treat unexpected values correctly.  Literals are <span class="RktSym">return</span>ed into the
monad if they appear where a monadic value should be.  Functions can return
a simple value, rather than a state-doublet, in which case the bind
assumes that the intent was to simple insert that value into the monad
without modifying the accumulating state.</p><p>State functions may also return either a <span class="RktSym">state-fail</span> struct
or a <span class="RktPn">(</span><span class="RktSym">state-error</span><span class="stt"> </span><span class="RktSym">error-value</span><span class="RktPn">)</span> struct to indicate failure.
Such return values short-circuit all further state function bindings.
For the state monad, then, <span class="RktSym">state-fail</span> is the monadic zero and
<span class="RktSym">state-error</span> allows the monad to report errors.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Other_.Utility_.Functions_.Forms)"></a>Other Utility Functions/Forms</h4><p>It is often convenient to "lift" a function into a monad.  This is
provided for by a suite of lift functions.  Because functions have variable
arity in Racket, you must specifiy the number of arguments to lift over, although
this can be specified at run time (unlike the Clojure library), up to 20 arguments.</p><p>Eg:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">list+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lift</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">the-list-monad</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">list+</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Short-cut functions of the form <span class="RktSym">lift1</span>,<span class="RktSym">lift2</span> and so on are also exported.</p><p>The library also exports <span class="RktSym">mapm</span> and <span class="RktSym">foldlm</span>.  The former takes
a monadic function and a list of values and returns a monadic function which
returns the list resulting from monadically binding those values through the monad.</p><p>The latter takes a monadic function, an initial state, and a list of values and
returns a monadic function which folds over those values in the monad, returning
a monadic value which is the result of that folding.  The function <span class="RktSym">reducem</span>
is the same, but assumes the initial value is the <span class="RktSym">car</span> of the list and folds over
the <span class="RktSym">cdr</span>.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Conclusions)"></a>Conclusions</h3><p>This should be enough to get you going.  Enjoy the monads!</p></div></div><div id="contextindicator">&nbsp;</div></body></html>